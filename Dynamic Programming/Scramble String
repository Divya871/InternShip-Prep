=====MEMO CODE====

class Solution {
public:
 
    
   bool isScramble(const string s1, const string s2) {
   
         int n=s1.length();
        if(s1.length()!=s2.length()){return false;}
       if(n==0){return true;}
        if(s1==s2){return true;}
        if(s1.length()<=1){return false;}
       
        
     
        
        for(int i=1;i<n;i++)
        {
           if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble (s1.substr(i, n - i), s2.substr(i, n - i)))
               {
            return true;
        }      
                if (isScramble(s1.substr(0, i),s2.substr(n - i, i)) && isScramble(s1.substr(i, n - i), s2.substr(0, n - i)))
               {
            return true;
        }}
               return false;}
};
              


====OPTI===


unordered_map<string,bool>map;
    bool solve(const string s1, const string s2)
    {
        if(s1.size()==1)
  {
      return s1==s2;
  }
       if(s1==s2){return true;}
        string key=s1+s2;
        
        if(map.find(key)!=map.end())
        {
            return map[key];
        }
        int n=s1.size();
         for(int i=1;i<n;i++)
        {
           if (solve(s1.substr(0, i), s2.substr(0, i)) && solve (s1.substr(i, n - i), s2.substr(i, n - i)))
               {
            return true;
        }      
                if (solve(s1.substr(0, i),s2.substr(n - i, i)) && solve(s1.substr(i, n - i), s2.substr(0, n - i)))
               {
            return map[key]=true;
        }}
               return map[key]=false;}
              
    
   bool isScramble(const string s1, const string s2) {
      int n=s1.size();
       return solve(s1,s2);
        
   }};
